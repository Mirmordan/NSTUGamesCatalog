#!/bin/bash

# Строгий режим: выход при ошибке, ошибка при использовании необъявленной переменной,
# код возврата пайплайна - это код последней команды с ошибкой.
# set -euo pipefail # Раскомментируйте для большей строгости, но тогда ошибки чтения файлов прервут скрипт.

# Название файла, в который будет записано содержимое
OUTPUT_FILE="content.txt"

# Получаем абсолютные пути к скрипту и файлу вывода для корректного пропуска
# readlink -f разрешает симлинки и делает путь абсолютным
# "$0" это путь вызова скрипта, может быть относительным или просто именем
SCRIPT_ABS_PATH=$(readlink -f "$0")
# OUTPUT_FILE может быть просто именем, readlink -f сделает его абсолютным относительно текущей директории
OUTPUT_ABS_PATH=$(readlink -f "$OUTPUT_FILE")


# 1) Скрипт создает (или перезаписывает) файл content.txt
>"$OUTPUT_FILE" # Создает пустой файл или очищает существующий
echo "Начинаю сборку файла: $OUTPUT_ABS_PATH"
echo "Скрипт запущен как: $SCRIPT_ABS_PATH"


# Функция для обработки одного файла: запись заголовка и содержимого
# $1 - путь к файлу для чтения
# $2 - путь к файлу для отображения в content.txt (обычно относительный)
process_file() {
    local file_to_read="$1"
    local file_to_display="$2"

    # Получаем абсолютный путь к текущему обрабатываемому файлу для сравнения
    local current_file_abs_path
    current_file_abs_path=$(readlink -f "$file_to_read")

    # Пропускаем сам файл вывода
    if [ "$current_file_abs_path" == "$OUTPUT_ABS_PATH" ]; then
        echo "  Пропускается: $file_to_display (файл вывода)"
        return
    fi

    # Пропускаем сам скрипт
    if [ "$current_file_abs_path" == "$SCRIPT_ABS_PATH" ]; then
        echo "  Пропускается: $file_to_display (этот скрипт)"
        return
    fi

    echo "  Добавляется: $file_to_display"
    echo "--- $file_to_display ---" >> "$OUTPUT_FILE"

    # Проверка на бинарный файл (эвристика: ищем непечатаемые символы)
    # LC_ALL=C нужно для того, чтобы [:print:] и [:space:] работали с ASCII байтами предсказуемо.
    if LC_ALL=C grep -q '[^[:print:][:space:]]' "$file_to_read"; then
        echo "[Содержимое не является текстом или содержит непечатаемые символы (файл может быть бинарным)]" >> "$OUTPUT_FILE"
    else
        # Если файл текстовый, записываем его содержимое
        cat "$file_to_read" >> "$OUTPUT_FILE"
    fi
    # Добавляем пару пустых строк для лучшей читаемости между файлами
    echo "" >> "$OUTPUT_FILE"
    echo "" >> "$OUTPUT_FILE"
}


# 2) Скрипт составляет список доступных файлов
#    (если есть git ignore в текущей папке, то он игнорирует файлы и папки оттуда)
# 3) Скрипт записывает файлы в content.txt
# 4) Скрипт повторяет алгоритм со 2 шага для всех поддиректорий (рекурсия встроена в find/git ls-files)

# Проверяем, находимся ли мы в Git репозитории
if git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
    echo "Обнаружен Git репозиторий. Используется .gitignore для фильтрации файлов."
    # Используем git ls-files для получения списка файлов, учитывая .gitignore
    # -c (или --cached) - отслеживаемые файлы
    # -o (или --others) - неотслеживаемые (но не игнорируемые) файлы
    # --exclude-standard - стандартные правила игнорирования Git (из .gitignore, .git/info/exclude, глобальный gitignore)
    # -z - имена файлов разделены NUL, для безопасной обработки имен с пробелами/спецсимволами
    # -- "$PWD" - искать файлы в текущей директории и ее поддиректориях.
    #              git ls-files выведет пути относительно "$PWD".
    #              Двойной дефис (--) используется для указания конца опций, чтобы имена файлов,
    #              начинающиеся с дефиса, не интерпретировались как опции.
    git ls-files --cached --others --exclude-standard -z -- "$PWD" | while IFS= read -r -d $'\0' filepath_from_git; do
        # git ls-files может вернуть директории (например, для подмодулей, которые не инициализированы)
        # Мы обрабатываем только обычные файлы (-f)
        if [ -f "$filepath_from_git" ]; then
            process_file "$filepath_from_git" "$filepath_from_git"
        else
            # Это может быть директория (например, подмодуль) или что-то еще.
            # Мы не записываем содержимое директорий, только файлов.
            echo "  Пропускается (не файл из git ls-files): $filepath_from_git"
        fi
    done
else
    echo "Git репозиторий не обнаружен. .gitignore не будет использован."
    echo "Обрабатываются все файлы рекурсивно из текущей директории (кроме .git/ и служебных)."
    # Используем find для поиска всех файлов.
    # -type f - искать только обычные файлы.
    # -print0 - имена файлов разделены NUL.
    # Пути от find будут начинаться с './' (например, ./file.txt, ./subdir/file.txt)
    find . -type f -print0 | while IFS= read -r -d $'\0' found_filepath; do
        # Удаляем начальные "./" для более чистого отображения пути в content.txt
        local display_path="${found_filepath#./}"

        # Явно пропускаем файлы из директории .git/
        if [[ "$found_filepath" == ./.git/* ]]; then
             echo "  Пропускается (внутри .git/): $display_path"
             continue
        fi
        # Остальные пропуски (скрипт, файл вывода) делаются внутри process_file
        process_file "$found_filepath" "$display_path"
    done
fi

echo ""
echo "Готово! Содержимое всех подходящих файлов записано в: $OUTPUT_ABS_PATH"
